SINGLECOMMENT	1
INT		int	2	0
ID		test_hexoct	2	4	
LPAREN	(	2	15
RPAREN	)	2	16
LBRACE	{	2	18
INT		int	3	4
ID		a	3	8	
PARSE	,	3	9
ID		b	3	11	
SEMICOLON	;	3	12
ID		a	4	4	
ASSIGN	=	4	6
HEX	0xf0aC	4	8	61612
SEMICOLON	;	4	14
ID		b	5	4	
ASSIGN	=	5	6
HEX	0XcBeF	5	8	52207
SEMICOLON	;	5	14
RETURN	return	6	4
ID		a	6	11	
ADD	+	6	13
ID		b	6	15	
ADD	+	6	17
OCTAL	075	6	19	61
SEMICOLON	;	6	22
RBRACE	}	7	0
SINGLECOMMENT	9
VOID	void	10	0
ID		test_float	10	5	
LPAREN	(	10	15
RPAREN	)	10	16
LBRACE	{	10	18
SINGLECOMMENT	11
CONST	const	12	4
FLOAT	float	12	10
ID		RADIUS	12	16	
ASSIGN	=	12	23
FLOAT	5.5	12	25	5.500000
PARSE	,	12	28
ID		PI	12	30	
ASSIGN	=	12	33
FLOAT	03.141592653589793	12	35	3.141593
PARSE	,	12	53
ID		EPS	12	55	
ASSIGN	=	12	59
FLOAT	1e-6	12	61	0.000001
SEMICOLON	;	12	65
FLOAT	float	13	4
ID		FACT	13	10	
ASSIGN	=	13	15
SUB	-	13	17
FLOAT	.33E+5	13	18	33000.000000
SEMICOLON	;	13	24
SINGLECOMMENT	14
CONST	const	15	4
FLOAT	float	15	10
ID		PI_HEX	15	16	
ASSIGN	=	15	23
HEX_FLOAT	0x1.921fb6p+1	15	25	3.141593
PARSE	,	15	38
ID		HEX2	15	40	
ASSIGN	=	15	45
HEX_FLOAT	0X.AP-3	15	47	0.078125
SEMICOLON	;	15	54
RBRACE	}	16	0
SINGLECOMMENT	18
VOID	void	19	0
ID		test_annotation	19	5	
LPAREN	(	19	20
RPAREN	)	19	21
LBRACE	{	19	23
INT		int	20	4
ID		f	20	8	
PARSE	,	20	9
ID		g	20	11	
PARSE	,	20	12
ID		h	20	14	
SEMICOLON	;	20	15
SINGLECOMMENT	21
ID		f	22	4	
ASSIGN	=	22	6
ID		g	22	8	
DIV	/	22	13
ID		h	22	14	
SEMICOLON	;	22	15
ID		f	23	11	
ASSIGN	=	23	13
ID		g	23	15	
MOD	%	23	17
ID		h	23	19	
SEMICOLON	;	23	20
ID		f	24	4	
ASSIGN	=	24	6
ID		g	24	8	
SINGLECOMMENT	24
ADD	+	25	4
ID		h	25	6	
SEMICOLON	;	25	7
RBRACE	}	27	0
SINGLECOMMENT	29
VOID	void	30	0
ID		test_terminal	30	5	
LPAREN	(	30	18
RPAREN	)	30	19
LBRACE	{	30	21
CONST	const	31	4
INT		int	31	10
ID		arr	31	14	
LBRACKET	[	31	17
DECIMAL	5	31	18	5
RBRACKET	]	31	19
ASSIGN	=	31	20
LBRACE	{	31	21
DECIMAL	0	31	22	0
PARSE	,	31	23
DECIMAL	1	31	24	1
PARSE	,	31	25
DECIMAL	2	31	26	2
PARSE	,	31	27
DECIMAL	3	31	28	3
PARSE	,	31	29
DECIMAL	4	31	30	4
RBRACE	}	31	31
SEMICOLON	;	31	32
INT		int	32	4
ID		a	32	8	
ASSIGN	=	32	10
LPAREN	(	32	12
ID		arr	32	13	
LBRACKET	[	32	16
DECIMAL	1	32	17	1
RBRACKET	]	32	18
ADD	+	32	20
DECIMAL	2	32	22	2
RPAREN	)	32	23
MUL	*	32	25
DECIMAL	3	32	27	3
DIV	/	32	29
DECIMAL	4	32	31	4
SUB	-	32	33
DECIMAL	5	32	35	5
MOD	%	32	37
DECIMAL	2	32	39	2
SEMICOLON	;	32	40
INT		int	33	4
ID		b	33	8	
PARSE	,	33	9
ID		c	33	11	
PARSE	,	33	12
ID		d	33	14	
SEMICOLON	;	33	15
WHILE	while	34	4
LPAREN	(	34	10
ID		a	34	11	
LESS	<	34	13
DECIMAL	75	34	15	75
RPAREN	)	34	17
LBRACE	{	34	19
ID		b	35	8	
ASSIGN	=	35	10
DECIMAL	42	35	12	42
SEMICOLON	;	35	14
IF	if	36	8
LPAREN	(	36	11
ID		a	36	12	
LE	<=	36	14
DECIMAL	99	36	17	99
RPAREN	)	36	19
LBRACE	{	36	21
ID		c	37	12	
ASSIGN	=	37	14
ID		b	37	16	
MUL	*	37	18
DECIMAL	2	37	20	2
SEMICOLON	;	37	21
IF	if	38	12
LPAREN	(	38	15
DECIMAL	1	38	16	1
EQ	==	38	18
DECIMAL	1	38	21	1
RPAREN	)	38	22
LBRACE	{	38	24
ID		a	39	16	
ASSIGN	=	39	18
ID		c	39	20	
MUL	*	39	22
DECIMAL	2	39	24	2
SEMICOLON	;	39	25
BREAK	break	40	16
SEMICOLON	;	40	21
RBRACE	}	41	12
RBRACE	}	42	8
RBRACE	}	43	4
ID		d	44	4	
ASSIGN	=	44	6
SUB	-	44	8
DECIMAL	2	44	9	2
SEMICOLON	;	44	10
IF	if	45	4
LPAREN	(	45	7
LPAREN	(	45	8
ID		c	45	9	
ADD	+	45	11
DECIMAL	3	45	13	3
RPAREN	)	45	14
MOD	%	45	16
DECIMAL	2	45	18	2
NEQ	!=	45	20
DECIMAL	0	45	23	0
RPAREN	)	45	24
LBRACE	{	45	26
LPAREN	(	46	14
ID		d	46	15	
RPAREN	)	46	16
SEMICOLON	;	46	17
RBRACE	}	47	4
RBRACE	}	48	0
SINGLECOMMENT	50
INT		int	51	0
ID		k	51	4	
SEMICOLON	;	51	5
VOID	void	52	0
ID		test_scope	52	5	
LPAREN	(	52	15
RPAREN	)	52	16
LBRACE	{	52	18
ID		k	53	4	
ASSIGN	=	53	6
DECIMAL	3389	53	8	3389
SEMICOLON	;	53	12
IF	if	54	4
LPAREN	(	54	7
ID		k	54	8	
LESS	<	54	10
DECIMAL	10000	54	12	10000
RPAREN	)	54	17
LBRACE	{	54	19
ID		k	55	8	
ASSIGN	=	55	10
ID		k	55	12	
ADD	+	55	14
DECIMAL	1	55	16	1
SEMICOLON	;	55	17
INT		int	56	8
ID		k	56	12	
ASSIGN	=	56	14
DECIMAL	112	56	16	112
SEMICOLON	;	56	19
ID		k	57	8	
ASSIGN	=	57	10
ID		k	57	12	
SUB	-	57	14
DECIMAL	88	57	16	88
SEMICOLON	;	57	18
RBRACE	}	58	4
LPAREN	(	59	10
ID		k	59	11	
RPAREN	)	59	12
SEMICOLON	;	59	13
RBRACE	}	60	0
